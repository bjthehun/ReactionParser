/*
 * generated by Xtext 2.41.0
 * 
 * modified by @bjthehun, @arlange:
 * - removed syntactical predicates
 * - removed unnecessary brackets around ~
 */
grammar DebugInternalReactionsLanguage;

@header {
package tools.vitruv.reactionsparser.parser.antlr;
}

// ReactionsFile
reactionsFile:
	xImportSection? metamodelImport* reactionsSegment+;

// MetamodelImport
metamodelImport:
	'import' RULE_STRING 'as' validID (
		'using' 'qualified' 'names'
	)?;

// ReactionsSegment
reactionsSegment:
	'reactions' ':' validID 'in' 'reaction' 'to' 'changes' 'in' RULE_ID (
		'and' RULE_ID
	)* 'execute' 'actions' 'in' RULE_ID ('and' RULE_ID)* reactionsImport* (
		reaction
		| routine
	)*;

// ReactionsImport
reactionsImport:
	'import' 'routines'? RULE_ID ('using' 'qualified' 'names')?;

// Reaction
reaction:
	RULE_ML_COMMENT? 'reaction' (RULE_ID '::')? validID '{' trigger routineCall '}';
// RoutineCall
routineCall: 'call' xExpression;

// Trigger
trigger: 'after' (arbitraryModelChange | concreteModelChange);

// ConcreteModelChange
concreteModelChange:
	(modelElementChange | modelAttributeChange);

// ModelElementChange
modelElementChange:
	'element' unnamedMetaclassReference? elementChangeType (
		'with' xExpression
	)?;

// ModelAttributeChange
modelAttributeChange:
	'attribute' (
		'inserted' 'in'
		| 'removed' 'from'
		| 'replaced' 'at'
	) metaclassEAttributeReference ('with' xExpression)?;
// ArbitraryModelChange
arbitraryModelChange: 'anychange' ( 'with' xExpression)?;

// ElementExistenceChangeType
elementExistenceChangeType:
	(elementCreationChangeType | elementDeletionChangeType);

// ElementUsageChangeType
elementUsageChangeType:
	(
		elementInsertionChangeType
		| elementRemovalChangeType
		| elementReplacementChangeType
	);

// ElementCreationChangeType
elementCreationChangeType: 'created';

// ElementDeletionChangeType
elementDeletionChangeType: 'deleted';

// ElementReferenceChangeType
elementReferenceChangeType: metaclassEReferenceReference;

// ElementInsertionChangeType
elementInsertionChangeType:
	(
		elementInsertionInListChangeType
		| elementInsertionAsRootChangeType
	);

// ElementInsertionInListChangeType
elementInsertionInListChangeType:
	'inserted' 'in' elementReferenceChangeType;

// ElementInsertionAsRootChangeType
elementInsertionAsRootChangeType: 'inserted' 'as' 'root';

// ElementRemovalChangeType
elementRemovalChangeType:
	(
		elementRemovalAsRootChangeType
		| elementRemovalFromListChangeType
	);

// ElementRemovalAsRootChangeType
elementRemovalAsRootChangeType: 'removed' 'as' 'root';

// ElementRemovalFromListChangeType
elementRemovalFromListChangeType:
	'removed' 'from' elementReferenceChangeType;

// ElementReplacementChangeType
elementReplacementChangeType:
	'replaced' 'at' elementReferenceChangeType;

// ElementChangeType
elementChangeType:
	(elementExistenceChangeType | elementUsageChangeType);

// Routine
routine:
	RULE_ML_COMMENT? 'routine' (routineOverrideImportPath '::')? validID routineInput '{' matchBlock
		? createBlock? updateBlock? '}';

// RoutineOverrideImportPath
routineOverrideImportPath: RULE_ID ( '.' RULE_ID)*;

// RoutineInput
routineInput:
	'(' (
		(
			namedMetaclassReference
			| 'plain' namedJavaElementReference
		) (
			',' (
				namedMetaclassReference
				| 'plain' namedJavaElementReference
			)
		)*
	)? ')';

// MatchBlock
matchBlock: 'match' '{' matchStatement+ '}';

// MatchStatement
matchStatement:
	(
		retrieveOrRequireAbscenceOfModelElement
		| matchCheckStatement
	);

// RetrieveOrRequireAbscenceOfModelElement
retrieveOrRequireAbscenceOfModelElement:
	(requireAbscenceOfModelElement | retrieveModelElement);

// RequireAbscenceOfModelElement
requireAbscenceOfModelElement:
	'require' 'absence' 'of' unnamedMetaclassReference 'corresponding' 'to' xExpression (
		'tagged' xExpression
	)? ('with' xExpression)?;

// RetrieveModelElement
retrieveModelElement:
	('val' validID '=')? 'retrieve' retrieveModelElementTypeStatement unnamedMetaclassReference
		'corresponding' 'to' xExpression ('tagged' xExpression)? (
		'with' xExpression
	)?;

// RetrieveModelElementTypeStatement
retrieveModelElementTypeStatement:
	(( 'optional' | 'asserted')? | 'many');

// MatchCheckStatement
matchCheckStatement: 'check' 'asserted'? xExpression;

// CreateBlock
createBlock: 'create' '{' createStatement* '}';

// CreateStatement
createStatement: 'val' validID '=' 'new' metaclassReference;

// UpdateBlock
updateBlock: 'update' xExpression;

// MetaclassReference
metaclassReference: ( RULE_ID '::')? qualifiedName;

// UnnamedMetaclassReference
unnamedMetaclassReference: metaclassReference;

// NamedMetaclassReference
namedMetaclassReference: metaclassReference validID;

// NamedJavaElementReference
namedJavaElementReference: jvmTypeReference 'as' validID;

// MetaclassEAttributeReference
metaclassEAttributeReference:
	metaclassReference '[' validID ']';

// MetaclassEReferenceReference
metaclassEReferenceReference:
	metaclassReference '[' validID ']';

// XExpression
xExpression: xAssignment;

// XAssignment
xAssignment:
	(
		featureCallID opSingleAssign xAssignment
		| xOrExpression (
			(
				// Syntactic predicate: When (ruleOpMultiAssign) is predicted, produce ruleOpMultiAssign
				(opMultiAssign)
			) xAssignment
		)?
	);

// OpSingleAssign
opSingleAssign: '=';

// OpMultiAssign
opMultiAssign:
	(
		'+='
		| '-='
		| '*='
		| '/='
		| '%='
		| '<' '<' '='
		| '>' '>'? '>='
	);

// XOrExpression
xOrExpression: xAndExpression (( (opOr)) xAndExpression)*;

// OpOr
opOr: '||';

// XAndExpression
xAndExpression:
	xEqualityExpression (( opAdd) xEqualityExpression)*;

// OpAnd
opAnd: '&&';

// XEqualityExpression
xEqualityExpression:
	xRelationalExpression (( opEquality) xRelationalExpression)*;

// OpEquality
opEquality: ( '==' | '!=' | '===' | '!==');

// XRelationalExpression
xRelationalExpression:
	xOtherOperatorExpression (
		( 'instanceof') jvmTypeReference
		| ( opCompare) xOtherOperatorExpression
	)*;

// OpCompare
opCompare: ( '>=' | '<' '=' | '>' | '<');

// XOtherOperatorExpression
xOtherOperatorExpression:
	xAdditiveExpression (( opOther) xAdditiveExpression)*;

// OpOther
opOther:
	(
		'->'
		| '..<'
		| '>' '..'
		| '..'
		| '=>'
		| '>' ( ( ('>' '>')) | '>')
		| '<' ( ( ('<' '<')) | '<' | '=>')
		| '<>'
		| '?:'
	);

// XAdditiveExpression
xAdditiveExpression:
	xMultiplicativeExpression (( opAdd) xMultiplicativeExpression)*;

// OpAdd
opAdd: ( '+' | '-');

// XMultiplicativeExpression
xMultiplicativeExpression:
	xUnaryOperation (( opMulti) xUnaryOperation)*;
// OpMulti
opMulti: ( '*' | '**' | '/' | '%');

// XUnaryOperation
xUnaryOperation: (opUnary xUnaryOperation | xCastedExpression);

// OpUnary
opUnary: ( '!' | '-' | '+');

// XCastedExpression
xCastedExpression: xPostfixOperation (( 'as') jvmTypeReference)*;

// XPostfixOperation
xPostfixOperation: xMemberFeatureCall ( opPostfix)?;

// OpPostfix
opPostfix: ( '++' | '--');

// XMemberFeatureCall
xMemberFeatureCall:
	xPrimaryExpression (
		((( '.' | '::') featureCallID opSingleAssign)) xAssignment
		| ((( '.' | '?.' | '::'))) (
			'<' jvmArgumentTypeReference (
				',' jvmArgumentTypeReference
			)* '>'
		)? idOrSuper (
			('(') (
				xShortClosure
				| xExpression ( ',' xExpression)*
			)? ')'
		)? (xClosure)?
	)*;

// XPrimaryExpression
xPrimaryExpression:
	(
		xConstructorCall
		| xBlockExpression
		| xSwitchExpression
		| xSynchronizedExpression
		| xFeatureCall
		| xLiteral
		| xIfExpression
		| xForLoopExpression
		| xBasicForLoopExpression
		| xWhileExpression
		| xDoWhileExpression
		| xThrowExpression
		| xReturnExpression
		| xTryCatchFinallyExpression
		| xParenthesizedExpression
	);

// XLiteral
xLiteral:
	(
		xCollectionLiteral
		| xClosure
		| xBooleanLiteral
		| xNumberLiteral
		| xNullLiteral
		| xStringLiteral
		| xTypeLiteral
	);

// XCollectionLiteral
xCollectionLiteral: ( xSetLiteral | xListLiteral);

// XSetLiteral
xSetLiteral: '#' '{' (xExpression ( ',' xExpression)*)? '}';

// XListLiteral
xListLiteral: '#' '[' (xExpression ( ',' xExpression)*)? ']';

// XClosure
xClosure:
	('[') (( ( jvmFormalParameter ( ',' jvmFormalParameter)*)? '|'))? xExpressionInClosure ']';

// XExpressionInClosure
xExpressionInClosure: ( xExpressionOrVarDeclaration ';'?)*;

// XShortClosure
xShortClosure:
	(( ( jvmFormalParameter ( ',' jvmFormalParameter)*)? '|')) xExpressionInClosure ']';

// XParenthesizedExpression
xParenthesizedExpression: '(' xExpression ')';

// XIfExpression
xIfExpression:
	'if' '(' xExpression ')' xExpression (( 'else') xExpression)?;

// XSwitchExpression
xSwitchExpression:
	'switch' (
		('(' jvmFormalParameter ':') xExpression ')'
		| ( jvmFormalParameter ':')? xExpression
	) '{' xCasePart* ('default' ':' xExpression)? '}';

// XCasePart
xCasePart:
	jvmTypeReference? ('case' xExpression)? (
		':' xExpression
		| ','
	);

// XForLoopExpression
xForLoopExpression:
	'for' '(' jvmFormalParameter ':' xExpression ')' xExpression;

// XBasicForLoopExpression
xBasicForLoopExpression:
	'for' '(' (
		xExpressionOrVarDeclaration (
			',' xExpressionOrVarDeclaration
		)*
	)? ';' xExpression? ';' (xExpression ( ',' xExpression)*)? ')' xExpression;

// XWhileExpression
xWhileExpression: 'while' '(' xExpression ')' xExpression;

// XDoWhileExpression
xDoWhileExpression:
	'do' xExpression 'while' '(' xExpression ')';

// XBlockExpression
xBlockExpression: '{' (xExpressionOrVarDeclaration ';'?)* '}';

// XExpressionOrVarDeclaration
xExpressionOrVarDeclaration:
	(xVariableDeclaration | xExpression);

// XVariableDeclaration
xVariableDeclaration:
	('var' | 'val') (( jvmTypeReference validID) | validID) (
		'=' xExpression
	)?;

// JvmFormalParameter
jvmFormalParameter: jvmTypeReference? validID;

// FullJvmFormalParameter
fullJvmFormalParameter: jvmTypeReference validID;

// XFeatureCall
xFeatureCall:
	(
		'<' jvmArgumentTypeReference (
			',' jvmArgumentTypeReference
		)* '>'
	)? idOrSuper (
		'(' (xShortClosure | xExpression ( ',' xExpression)*)? ')'
	)? (xClosure)?;

// FeatureCallID
featureCallID:
	(validID | 'extends' | 'static' | 'import' | 'extension');

// IdOrSuper
idOrSuper: ( featureCallID | 'super');

// XConstructorCall
xConstructorCall:
	'new' qualifiedName (
		'<' jvmArgumentTypeReference (
			',' jvmArgumentTypeReference
		)* '>'
	)? (
		'(' (xShortClosure | xExpression ( ',' xExpression)*)? ')'
	)? (xClosure)?;

// XBooleanLiteral
xBooleanLiteral: ( 'false' | 'true');

// XNullLiteral
xNullLiteral: 'null';

// XNumberLiteral
xNumberLiteral: number;
// XStringLiteral
xStringLiteral: RULE_STRING;

// XTypeLiteral
xTypeLiteral: 'typeof' '(' qualifiedName arrayBrackets* ')';

// XThrowExpression
xThrowExpression: 'throw' xExpression;

// XReturnExpression
xReturnExpression: 'return' xExpression?;

// XTryCatchFinallyExpression
xTryCatchFinallyExpression:
	'try' xExpression (
		xCatchClause+ ('finally' xExpression)?
		| 'finally' xExpression
	);

// XSynchronizedExpression
xSynchronizedExpression:
	'synchronized' '(' xExpression ')' xExpression;

// XCatchClause
xCatchClause:
	('catch') '(' fullJvmFormalParameter ')' xExpression;

// QualifiedName
qualifiedName: validID ( '.' validID)*;

// Number
number:
	(
		RULE_HEX
		| (RULE_INT | RULE_DECIMAL) (
			'.' ( RULE_INT | RULE_DECIMAL)
		)?
	);

// JvmTypeReference
jvmTypeReference:
	(
		jvmParameterizedTypeReference (arrayBrackets)*
		| xFunctionTypeRef
	);

// ArrayBrackets
arrayBrackets: '[' ']';

// XFunctionTypeRef
xFunctionTypeRef:
	('(' ( jvmTypeReference ( ',' jvmTypeReference)*)? ')')? '=>' jvmTypeReference;

// JvmParameterizedTypeReference
jvmParameterizedTypeReference:
	qualifiedName (
		('<') jvmArgumentTypeReference (
			',' jvmArgumentTypeReference
		)* '>' (
			('.') validID (
				('<') jvmArgumentTypeReference (
					',' jvmArgumentTypeReference
				)* '>'
			)?
		)*
	)?;

// JvmArgumentTypeReference
jvmArgumentTypeReference:
	(jvmTypeReference | jvmWildcardTypeReference);
// JvmWildcardTypeReference
jvmWildcardTypeReference:
	'?' (
		jvmUpperBound jvmUpperBoundAnded*
		| jvmLowerBound jvmLowerBoundAnded*
	)?;

// JvmUpperBound
jvmUpperBound: 'extends' jvmTypeReference;

// JvmUpperBoundAnded
jvmUpperBoundAnded: '&' jvmTypeReference;

// JvmLowerBound
jvmLowerBound: 'super' jvmTypeReference;

// JvmLowerBoundAnded
jvmLowerBoundAnded: '&' jvmTypeReference;

// QualifiedNameWithWildcard
qualifiedNameWithWildcard: qualifiedName '.' '*';
// ValidID
validID: RULE_ID;

// XImportSection
xImportSection: xImportDeclaration+;

// XImportDeclaration
xImportDeclaration:
	'import' (
		'static' 'extension'? qualifiedNameInStaticImport (
			'*'
			| validID
		)
		| qualifiedName
		| qualifiedNameWithWildcard
	) ';'?;

// QualifiedNameInStaticImport
qualifiedNameInStaticImport: ( validID '.')+;

RULE_HEX: ('0x' | '0X') (
		'0' ..'9'
		| 'a' ..'f'
		| 'A' ..'F'
		| '_'
	)+ ('#' (('b' | 'B') ('i' | 'I') | ('l' | 'L')))?;

RULE_INT: '0' ..'9' ('0' ..'9' | '_')*;

RULE_DECIMAL:
	RULE_INT (('e' | 'E') ('+' | '-')? RULE_INT)? (
		('b' | 'B') ('i' | 'I' | 'd' | 'D')
		| ('l' | 'L' | 'd' | 'D' | 'f' | 'F')
	)?;

RULE_ID:
	'^'? ('a' ..'z' | 'A' ..'Z' | '$' | '_') (
		'a' ..'z'
		| 'A' ..'Z'
		| '$'
		| '_'
		| '0' ..'9'
	)*;

RULE_STRING: (
		'"' ('\\' . | ~('\\' | '"'))* '"'?
		| '\'' ('\\' . | ~('\\' | '\''))* '\''?
	);

RULE_ML_COMMENT: '/*' .*? '*/';

// Single Line Comment:
// "//" followed by anything other than newline
// Comments are unparsed, but still in the token stream
RULE_SL_COMMENT : '//' ~('\n'|'\r')* ('\r'? '\n')? -> channel(HIDDEN);

// Whitespace also should be in the token stream for error recovery
RULE_WS : (' '|'\t'|'\r'|'\n')+ -> channel(HIDDEN);

RULE_ANY_OTHER : .;
